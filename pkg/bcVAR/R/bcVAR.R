"bcVAR" <- function(data = data, p = 1, type = c("const", "none"), ...){
  
  ## dimensions
  T <- nrow(data)
  K <- ncol(data)
  
  ## data transposed
  y <- t(as.matrix(data)) 
  
  ## stop if there are missing values in the data
  if (any(is.na(y))) 
    stop("\nNAs in data.\n")

  ## K-dimensional VAR(p) process can be written as a pK-dimensional VAR(1)
  Y <- y[, p:T] # first step for Y_t (see Kilian, L., and Luetkepohl, H. (2017) p. 25)

  if (p >= 2) {
    for (i in 1:(p - 1)){
    Y <- rbind(Y, y[, (p - i):(T - i)]) # second step for Y_t
    }
  }
    
  ## check if a constant vector should be included or not
  if (type == "none"){
    LY <- Y[, 1:(T-p)] # Y_(t-1) (see Kilian, L., and Luetkepohl, H. (2017) p. 25)
  } else {
    LY <- rbind(matrix(1, 1, T-p), Y[, 1:(T-p)])  # Y_(t-1) with a vector of ones for the constants
  }
  Y <- Y[, 2:(T-p+1)] # last step for Y_t
  
  ## estimation by OLS (reduced-form)
  Ahat <- lm.fit(t(LY), t(Y))$coefficients
  Ahat <- t(Ahat)

  ## split up Ahat (constant, coeff)
  if (type == "none"){
    A.companion.hat <- Ahat[, 1:dim(Ahat)[2]]
  } else {
    const <- Ahat[1:K, 1]
    A.companion.hat <- Ahat[, 2:dim(Ahat)[2]]
  }

  ## estiamted reduced-form residuals
  Uhat <- Y - Ahat%*%LY
  residuals <- t(Uhat[1:K, ])
  
  ## cov-var matrix reduced-form residuals
  SIGMAU <- tcrossprod(Uhat)*(T-p-K*p-1)^(-1)
  
  ## Bias-corrected LS (Kilian, L., and Luetkepohl, H. (2017) p. 36) ##
  tA <- t(A.companion.hat)
  I <- diag(K*p)
  
  ## computing GAMMA_Y(0)
  # vecSIGMAY <- solve(diag((K*p)^2) - kronecker(A.companion.hat, A.companion.hat)) %*% matrix(as.vector(SIGMAU))
  vecSIGMAY <- solve(diag((K*p)^2) - kronecker(A.companion.hat, A.companion.hat), matrix(as.vector(SIGMAU)))  
  dim(vecSIGMAY) <- c(K*p, K*p)          
  GAMMAY <- vecSIGMAY
  
  ## eigenvalues of A, the companion form of the estiamted slope parameters
  e <- eigen(A.companion.hat)
  
  ## the sum is over the eigenvalues of A, weighted by their multiplicities
  list <- list()
  for (i  in 1:(K*p)){
    list[[i]] <- e$values[i]*solve(I-e$values[i]*tA)
  }
  sumeigen <- Re(as.matrix(Reduce('+', list))) 
  
  ## computing the bias-correction
  BA <- SIGMAU%*%(solve(I-tA) + tA%*%solve(I-tA%*%tA) + sumeigen)%*%solve(GAMMAY) 
  correction <- BA/(T-p)
  
  ## adding the bias-correction to A
  bcLS <- A.companion.hat + correction
  
  ## check if there is a constant vector included to combine the bias-corrected LS and the constant
  if (type == "none"){
    coeff <- bcLS
  } else {
    coeff <- cbind(bcLS, const)
  }
  
  ## generates a datamatrix identical to datamat generated by VAR() of the vars package (Pfaff, 2008)
  p1 <- p + 1
  datamat <- y[ , p1:T]
  for (i in 1:(p1 - 1)){
    datamat <- rbind(datamat, y[, (p1 - i):(T - i)])
  } 
  if (type == "none"){
    datamat <- datamat
  } else {
    datamat <- rbind(datamat, matrix(1, 1, T - p))
    rownames(datamat)[K*p1 + 1] <- "const"
  }
  datamat <- as.data.frame(t(datamat))
  
  ## rename datamat (add lags)
  temp0 <- NULL
  for (i in 1:p) {
    temp1 <- paste(colnames(data), ".l", i, sep = "")
    temp0 <- c(temp0, temp1)
  }
  names <- c(temp0, "const")
  names(datamat)[(K + 1):(K + K*p + 1)] <- names

  ## save the results like the vars package (Pfaff, 2008)
  varresult <- list()
  for (i in 1:K){
    varresult[[i]] <- list()
    class(varresult[[i]]) <- "lm"
    varresult[[i]]$coefficients <- coeff[i, ]
    names(varresult[[i]]$coefficients) <- names
    varresult[[i]]$residuals <- residuals[, i]
  }
  names(varresult) <- c(colnames(data))
  
  call <- match.call()
  
  ## return the results
  result <- list(
    varresult = varresult,
    datamat = datamat, 
    y = as.matrix(data),
    type = type, 
    p = p, 
    K = K,
    obs = T - p,
    totobs = T,
    restrictions = NULL,
    call = call
  )
  
  ## assign class attribute to the object 
  class(result) <- "varest" # same class as of VAR() from the vars package (Pfaff, 2008)
  return(result)
  
}





